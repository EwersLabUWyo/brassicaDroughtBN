# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# Convert back to dataframe for easy subsetting.
counts <- as.data.frame(counts)
# Add 1 to the count with the 2nd highest proportion if
# still less than 12.
counts[counts$total <= 11 & counts$Prop == counts$max2, 'round'] <-
counts[counts$total <= 11
& counts$Prop == counts$max2, 'round'] + 1
# Convert back to data table for easy updating.
counts <- as.data.table(counts)
# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# If there are any column totals of 13, subtract one from the
# value with the lowest proportion.
counts[counts$total == 13 & counts$Prop == counts$min, 'round'] <-
counts[counts$total == 13
& counts$Prop == counts$min, 'round'] - 1
# Convert back to data table for easy updating.
counts <- as.data.table(counts)
# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# Bind round column to mod dataframe.
mod <- cbind(mod, counts$round)
}
# Remove unneccesary dataframes.
rm(tr)
rm(c1)
rm(i)
rm(ph)
rm(cl)
rm(discRNA)
rm(module)
# Rename modules in mod dataframe.
colnames(mod)[5:dim(mod)[2]] <- paste("M", 2:10, sep = "")
# Expand modules to match the number of -1, 0, and 1's that should be
# in the RNA-Seq dataframe.
RNAmod <- as.data.frame(sapply(mod[, 4:dim(mod)[2]], function(x) rep(mod$Value, times = x)))
#### Pheno.
# Read in phenotype file.
Pheno <- read.csv(file = "PhenoBrassicaImp.csv", row.names = 1)
# Rename SM... to get rid of periods.
colnames(Pheno)[8] <- "SM"
# Add a column for Time of Day, named TOD.
Pheno$TOD <- rep(c(7, 11, 15, 19, 23, 3), each = 24, 2)
#### Discretize data.
# Discretize the phenotype data, excluding fluorescence.
phenoDisc <- discretize(Pheno[, c(3, 4, 6, 7, 8)],
method = "interval",
breaks = c(5, 5, 5, 5, 5))
# Use arules package to discretize fluorescence and detach due
# to the overlap in package functions with bnlearn.
library(arules)
fluor <- discretize(Pheno[, 5], method = "cluster")
detach("package:arules", unload=TRUE)
# Attach fluorescence data to phenoDisc dataframe.
phenoDisc$fluor <- fluor
# Add INT column to discretized data.
phenoDisc$INT <- as.factor(Pheno$Treatment)
# Add Timepoint column to discretized data.
phenoDisc$TP <- as.factor(Pheno$Timepoint)
# Order Pheno dataframe by Timepoint and int.
phenoDisc <- phenoDisc[with(phenoDisc, order(TP, INT)), ]
# Combine pheno and RNA data frames.
rnaPheno <- cbind(phenoDisc, RNAmod)
# Remove unneccesary dataframes.
rm(phenoDisc)
rm(Pheno)
# Remove extra columns.
rnaPheno$Trmt <- NULL
rnaPheno$INT <- NULL
rnaPheno$TP <- NULL
rnaPheno$TP <- NULL
View(rnaPheno)
wh <- data.frame(from = c("SM", "gs", "Photo"), to = c("gs", "Photo", "fluor"))
bl <- tiers2blacklist(list(colnames(training)[5], colnames(training)[-5]))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
bl
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
View(rnaPheno)
which()
wh
install.packages("arules")
# Set working directory.
# setwd("E:/Mallory Lai/PhenoRNAnetworkBrassica")
#setwd("/Users/mblai/Documents/GitHub/PhenoRNAnetworkBrassica")
######## RNA
# Read in RNAseq data.
RNA <- read.csv(file = "largeDE.csv", row.names = 1)
## Transpose data.
RNA <- t(RNA)
# Convert to data.frame.
RNA <- as.data.frame(RNA)
# Discretize the data.
discRNA <- discretize(RNA, method = "quantile", breaks = 3)
# Split rownames into Treatment/Timepoint and Replicate.
rnaNames <- str_split_fixed(rownames(RNA), '_', 2)
# Create a Timepoint column.
discRNA$Timepoint <- as.numeric(str_split_fixed(rnaNames[, 1], '', 2)[, 2])
# Create a treatment column named int.
discRNA$int <- as.factor(str_split_fixed(rnaNames[, 1], '', 2)[, 1])
# Remove rnaNames vector and RNA dataframe.
rm(rnaNames)
rm(RNA)
# Order RNA dataframe by Timepoint and int.
discRNA <- discRNA[with(discRNA, order(Timepoint, int)), ]
# Convert data intervals to -1, 0, and 1 representing low, medium, and high.
for (i in 1:(dim(discRNA)[2] - 2)){
levels(discRNA[, i]) <- c(-1, 0, 1)
discRNA[, i] <- as.factor(discRNA[, i])
}
# Transform RNA data frame.
discRNA <- t(discRNA)
# Rename column names to match timepoint and treatment.
colnames(discRNA) <- paste(discRNA[dim(discRNA)[1] - 1,],
discRNA[dim(discRNA)[1],], sep = "")
# Read in cluster classification.
tr <- read.csv(file = "pg.csv")
# Rename column names to "variable" and "cluster."
colnames(tr) <- c("variable", "cluster")
# Remove phenotype variables.
ph <- c("Photo", "gs", "Fv.Fm.", "Starch", "NSC", "SM")
tr <- tr[-which(tr$variable %in% ph), ]
# Create empty matrix for storing clusters.
cl <- matrix(data = NA, nrow = dim(tr)[1], ncol = (max(unique(tr$cluster))))
colnames(cl) <- paste("c", 1:(max(unique(tr$cluster))), sep = "")
# Separate by clusters.
for (i in 1:(max(unique(tr$cluster))))
{
cl[, i] <- c(as.character(tr[tr$cluster == i, "variable"]),
rep(NA, length(cl[,i]) - dim(tr[tr$cluster == i, ])[1]))
}
# Separate clusters to form gene modules.
c1 <- discRNA[c(cl[1:(length(cl[,1]) - sum(is.na(cl[,1]))), 1]), ]
# Add timepoint and treatment row.
c1 <- rbind(c1, TP = discRNA[dim(discRNA)[1] - 1,], Trmt = discRNA[dim(discRNA)[1],])
# Transpose.
c1 <- as.data.frame(t(c1))
# Gather all genes into one gene module, M1.
m1 <- gather(c1, Gene, M1, -TP, -Trmt)
# Count number of values per treatment and time point.
mCounts <- as.data.frame(table(m1[, c(1, 2, 4)]))
# Order mCounts dataframe by Timepoint, treatment, and module value.
mCounts <- mCounts[with(mCounts, order(TP, Trmt, M1)), ]
# Add column for proportion per timepoint, treatment, and module value.
mCounts$Prop <- mCounts$Freq/((length(cl[,1]) - sum(is.na(cl[,1])))*2)
# Create a column with the number of counts proportional to 12.
mCounts$twelve <- mCounts$Prop * 12
# Round the counts proportional to 12.
mCounts$round <- round(mCounts$twelve)
# Convert to data.table.
mCounts <- as.data.table(mCounts)
# Add a column that counts the total in round.
mCounts <- mCounts[, total := sum(round), by = list(TP, Trmt)]
# Convert to dataframe for easier updates.
mCounts <- as.data.frame(mCounts)
# If total count is 13, round to nearest 1/2 number and then round that.
mCounts[mCounts$total == 13, 'round'] <- round(round(mCounts[mCounts$total == 13, 'twelve']/0.5) *.5)
# Convert back to data table for easy updating.
mCounts <- as.data.table(mCounts)
# Update the total column with new rounding.
mCounts <- mCounts[, total := sum(round), by = list(TP, Trmt)]
# Add a column that identifies the max proportion per treatment and time point.
mCounts <- mCounts[, max := max(Prop), by = list(TP, Trmt)]
# Convert back to dataframe for easy subsetting.
mCounts <- as.data.frame(mCounts)
# Add 1 to the count with the max proportion.
mCounts[mCounts$total == 11 & mCounts$Prop == mCounts$max, 'round'] <-
mCounts[mCounts$total == 11
& mCounts$Prop == mCounts$max, 'round'] + 1
# Convert back to data table for easy updating.
mCounts <- as.data.table(mCounts)
# Update the total column with new rounding.
mCounts <- mCounts[, total := sum(round), by = list(TP, Trmt)]
# Extract the round column as a dataframe.
mod <- data.frame(TP = mCounts$TP, Trmt = mCounts$Trmt,
Value = mCounts$M1, M1 = mCounts$round)
# Remove unnecessary dataframes.
rm(m1)
rm(c1)
rm(mCounts)
############ TO DO: Update loop to perform a similar function as above.
# Loop through remaining clusters.
for (i in 3:(dim(cl)[2]))
{
# Separate clusters to form gene modules.
c1 <- discRNA[c(cl[1:(length(cl[,i]) - sum(is.na(cl[,i]))), i]), ]
# Add timepoint and treatment row.
c1 <- rbind(c1, TP = discRNA[dim(discRNA)[1] - 1,], Trmt = discRNA[dim(discRNA)[1],])
# Transpose.
c1 <- as.data.frame(t(c1))
# Gather all genes into one gene module
module <- gather(c1, Gene, M, -TP, -Trmt)
# Order module dataframe by Timepoint and int.
module <- module[with(module, order(TP, Trmt)), ]
# Count number of values per treatment and time point.
counts <- as.data.frame(table(module[, c(1, 2, 4)]))
# Order mCounts dataframe by Timepoint, treatment, and module value.
counts <- counts[with(counts, order(TP, Trmt, M)), ]
# Add column for proportion per timepoint, treatment, and module value.
counts$Prop <- counts$Freq/((length(cl[,i]) - sum(is.na(cl[,i])))*2)
# Create a column with the number of counts proportional to 12.
counts$twelve <- counts$Prop * 12
# Round the counts proportional to 12.
counts$round <- round(counts$twelve)
# Convert to data.table.
counts <- as.data.table(counts)
# Add a column that counts the total in round.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# Convert to dataframe for easier updates.
counts <- as.data.frame(counts)
# If total count is 13, round to nearest 1/2 number and then round that.
counts[counts$total == 13, 'round'] <- round(round(counts[counts$total == 13, 'twelve']/0.5) *.5)
# Convert back to data table for easy updating.
counts <- as.data.table(counts)
# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# Add a column that identifies the max proportion per treatment and time point.
counts <- counts[, max := max(Prop), by = list(TP, Trmt)]
# Add a column that identifies the second highest proportion per treatment
# and time point.
counts <- counts[, max2 := as.numeric(Prop)][, max2 := sort(Prop, T)[2], by = list(TP, Trmt)]
# Add a column that identifies the min proportion per treatment and time point.
counts <- counts[, min := min(Prop), by = list(TP, Trmt)]
# Convert back to dataframe for easy subsetting.
counts <- as.data.frame(counts)
# Add 1 to the count with the max proportion.
counts[counts$total <= 11 & counts$Prop == counts$max, 'round'] <-
counts[counts$total <= 11
& counts$Prop == counts$max, 'round'] + 1
# Convert back to data table for easy updating.
counts <- as.data.table(counts)
# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# Convert back to dataframe for easy subsetting.
counts <- as.data.frame(counts)
# Add 1 to the count with the 2nd highest proportion if
# still less than 12.
counts[counts$total <= 11 & counts$Prop == counts$max2, 'round'] <-
counts[counts$total <= 11
& counts$Prop == counts$max2, 'round'] + 1
# Convert back to data table for easy updating.
counts <- as.data.table(counts)
# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# If there are any column totals of 13, subtract one from the
# value with the lowest proportion.
counts[counts$total == 13 & counts$Prop == counts$min, 'round'] <-
counts[counts$total == 13
& counts$Prop == counts$min, 'round'] - 1
# Convert back to data table for easy updating.
counts <- as.data.table(counts)
# Update the total column with new rounding.
counts <- counts[, total := sum(round), by = list(TP, Trmt)]
# Bind round column to mod dataframe.
mod <- cbind(mod, counts$round)
}
# Remove unneccesary dataframes.
rm(tr)
rm(c1)
rm(i)
rm(ph)
rm(cl)
rm(discRNA)
rm(module)
# Rename modules in mod dataframe.
colnames(mod)[5:dim(mod)[2]] <- paste("M", 2:10, sep = "")
# Expand modules to match the number of -1, 0, and 1's that should be
# in the RNA-Seq dataframe.
RNAmod <- as.data.frame(sapply(mod[, 4:dim(mod)[2]], function(x) rep(mod$Value, times = x)))
#### Pheno.
# Read in phenotype file.
Pheno <- read.csv(file = "PhenoBrassicaImp.csv", row.names = 1)
# Rename SM... to get rid of periods.
colnames(Pheno)[8] <- "SM"
# Add a column for Time of Day, named TOD.
Pheno$TOD <- rep(c(7, 11, 15, 19, 23, 3), each = 24, 2)
#### Discretize data.
# Discretize the phenotype data, excluding fluorescence.
phenoDisc <- discretize(Pheno[, c(3, 4, 6, 7, 8)],
method = "interval",
breaks = c(5, 5, 5, 5, 5))
# Use arules package to discretize fluorescence and detach due
# to the overlap in package functions with bnlearn.
library(arules)
fluor <- discretize(Pheno[, 5], method = "cluster")
detach("package:arules", unload=TRUE)
# Attach fluorescence data to phenoDisc dataframe.
phenoDisc$fluor <- fluor
# Add INT column to discretized data.
phenoDisc$INT <- as.factor(Pheno$Treatment)
# Add Timepoint column to discretized data.
phenoDisc$TP <- as.factor(Pheno$Timepoint)
# Order Pheno dataframe by Timepoint and int.
phenoDisc <- phenoDisc[with(phenoDisc, order(TP, INT)), ]
# Combine pheno and RNA data frames.
rnaPheno <- cbind(phenoDisc, RNAmod)
# Remove unneccesary dataframes.
rm(phenoDisc)
rm(Pheno)
# Remove extra columns.
rnaPheno$Trmt <- NULL
rnaPheno$INT <- NULL
rnaPheno$TP <- NULL
rnaPheno$TP <- NULL
wh <- data.frame(from = c("SM", "gs", "Photo"), to = c("gs", "Photo", "fluor"))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
View(bl)
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
set.seed(3)
testData <- sample(1:dim(rnaPheno)[1], round(dim(rnaPheno)[1]*.1), replace = F)
test <- rnaPheno[testData, ]
training <- rnaPheno[-testData, ]
bn <- suppressWarnings(tabu(training, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
boot <- boot.strength(training, R = 250, algorithm = "tabu",
whitelist = wh, blacklist = bl,
algorithm.args = list(score = "bde", iss = 10))
boot <- boot.strength(training, R = 250, algorithm = "tabu",
algorithm.args = list(score = "bde", iss = 10,
whitelist = wh, blacklist = bl,))
boot <- boot.strength(training, R = 250, algorithm = "tabu",
algorithm.args = list(score = "bde", iss = 10))
boot[(boot$strength > 0.85) & (boot$direction >= 0.5), ]
avg.boot <- averaged.network(boot, threshold = 0.85)
plot(avg.boot)
nodes <- names(rnaPheno)
start <- random.graph(nodes = nodes, method = "ic-dag", num = 100,
every = 3)
netlist <- suppressWarnings(lapply(start, function(net){
tabu(rnaPheno, score = "bde", whitelist = wh, blacklist = bl, tabu = 50, iss = 10)
}))
rnd <- custom.strength(netlist, nodes = nodes)
modelAvg <- rnd[(rnd$strength > .95) & (rnd$direction >= .5), ]
avg.start <- averaged.network(rnd, threshold = .9)
plot(avg.start)
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
wh <- data.frame(from = c("SM", "gs", "Photo", "NSC", "M10", "M6"),
to = c("gs", "Photo", "fluor", "Starch", "Photo", "gs"))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
wh <- data.frame(from = c("SM", "gs", "Photo", "NSC", "M10", "M6", "M1"),
to = c("gs", "Photo", "fluor", "Starch", "Photo", "gs", "M4"))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
wh <- data.frame(from = c("SM", "gs", "Photo", "NSC", "M10", "M6", "M1", "M10"),
to = c("gs", "Photo", "fluor", "Starch", "Photo", "gs", "M4", "M8"))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
wh <- data.frame(from = c("SM", "gs", "Photo", "NSC", "M10", "M1", "M10"),
to = c("gs", "Photo", "fluor", "Starch", "Photo", "M4", "M8"))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
wh <- data.frame(from = c("SM", "gs", "Photo", "NSC", "M10", "M6", "M1", "M10"),
to = c("gs", "Photo", "fluor", "Starch", "Photo", "gs", "M4", "M8"))
bl <- tiers2blacklist(list(colnames(rnaPheno)[5], colnames(rnaPheno)[-5]))
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
iss = 10, tabu = 50))
plot(bn)
bn <- suppressWarnings(tabu(rnaPheno, score = "bde", whitelist = wh,
blacklist = bl, iss = 10, tabu = 50))
plot(bn)
nodes <- names(rnaPheno)
start <- random.graph(nodes = nodes, method = "ic-dag", num = 500,
every = 50)
rsmax2(training, whitelist = wh, blacklist =bl,
restrict = "aracne",
maximize = "tabu", score = "bde",
maximize.args = list(iss = 5))
netlist <- suppressWarnings(lapply(start, function(net){
rsmax2(training, whitelist = wh, blacklist =bl,
restrict = "aracne",
maximize = "tabu", score = "bde",
maximize.args = list(iss = 5))
}))
rnd <- custom.strength(netlist, nodes = nodes)
modelAvg <- rnd[(rnd$strength > .85) & (rnd$direction >= .5), ]
avg.start <- averaged.network(rnd, threshold = .85)
plot(avg.start)
avg.start$arcs
write.csv(avg.start$arcs, file = "RNAphenoBN.csv")
?model2network
modelstring(avg.start)
bn <- suppressWarnings(tabu(training, score = "bde",
whitelist = wh, blacklist = bl,
iss = 10, tabu = 50))
plot(bn)
b<-  rsmax2(training, whitelist = wh, blacklist =bl,
restrict = "aracne",
maximize = "tabu", score = "bde",
maximize.args = list(iss = 5))
plot(b)
modelstring(bn)
plot(bn)
dag <- model2network("[SM][M10][M6|M10][gs|SM:M6][Photo|gs:M10][NSC|Photo][M7|Photo:M6][Starch|NSC][M9|M7:M10][fluor|Photo:M9][M2|M7:M9][M3|M6:M9][M1|fluor:M2:M10][M5|fluor:M3:M9][M4|M1:M9][M8|M1:M6:M10]")
dag
plot(dag)
plot(bn)
parents(bn$M6)
parents(bn$nodes)
dag <- model2network("[SM][M10][M6|M10][gs|SM:M6]")
plot(dag)
# Load Bayesian network package bnlearn.
library(bnlearn)
# Load network structure learned in clusteredRNApheno3.R.
dag <- model2network("[SM][M10][M6|M10][gs|SM:M6][Photo|gs:M10][NSC|Photo][M7|Photo:M6][Starch|NSC][M9|M7:M10][fluor|Photo:M9][M2|M7:M9][M3|M6:M9][M1|fluor:M2:M10][M5|fluor:M3:M9][M4|M1:M9][M8|M1:M6:M10]")
# Plot network.
plot(dag)
write.csv(rnaPheno, file = "RNAphenoBN.csv")
rnaPheno <- read.csv(file = "RNAphenoBN.csv")
View(rnaPheno)
rnaPheno <- read.csv(file = "RNAphenoBN.csv", row.names = 1)
View(rnaPheno)
bn <- bn.fit(dag, rnaPheno, method = "bayes")
View(rnaPheno)
dim(rnaPheno)
rnaPheno[, 7:16] <- as.factor(rnaPheno[, 7:16])
rnaPheno[, 7:dim(rnaPheno)[2]] <- lapply(rnaPheno[, 7:dim(rnaPheno)[2]], factor)
bn <- bn.fit(dag, rnaPheno, method = "bayes")
bn.fit.barchart(bn$M10)
bn.fit.barchart(bn$M6)
bn.fit.barchart(bn$M6, main = "P(M6|M10)")
# Load phenotype and transcriptome data for parameter learning.
rnaPheno <- read.csv(file = "RNAphenoBN.csv", row.names = 1)
# Convert modules to factors.
rnaPheno[, 7:dim(rnaPheno)[2]] <- lapply(rnaPheno[, 7:dim(rnaPheno)[2]], factor)
# Perform parameter learning for data using network structure from first R chunk.
bn <- bn.fit(dag, rnaPheno, method = "bayes")
bn.fit.barchart(bn$gs, main = "P(M6|M10)")
parents(bn$gs)
bn$gs
bn.fit.barchart(bn$M10, main = "P(M6|M10)")
rnaPheno <- read.csv(file = "RNAphenoBN.csv", row.names = 1)
hist(rnaPheno$M10)
hist(rnaPheno$M9)
hist(rnaPheno$M8)
hist(rnaPheno$M7)
hist(rnaPheno$M6)
hist(rnaPheno$M5)
hist(rnaPheno$M4)
hist(rnaPheno$M3)
hist(rnaPheno$M2)
hist(rnaPheno$M1)
bn.fit.barchart(bn$gs, main = "P(gs|SM,M6)")
# Plot barchart of M6 distribution.
bn.fit.barchart(bn$gs, main = "P(gs|SM,M6)")
bn.fit.barchart(bn$gs, main = "P(gs|SM,M6)")
dag <- model2network("[SM][M10][M6|M10][gs|SM:M6][Photo|gs:M10]
[NSC|Photo][M7|Photo:M6][Starch|NSC][M9|M7:M10]
[fluor|Photo:M9][M2|M7:M9][M3|M6:M9]
[M1|fluor:M2:M10][M5|fluor:M3:M9][M4|M1:M9]
[M8|M1:M6:M10]")
plot(dag)
plot(dag, col = "red")
?read.csv
bn$gs$prob
data.frame(bn$gs$prob)
levels(bn$gs)
levels(rnaPheno$gs)
gs <- data.frame(bn$gs$prob)
levels(gs)
levels(gs$gs)
?gsub
gsub("[", "(", gs)
gsub("[", "(", gs$gs)
grep("[",  gs$gs)
grepl("[",  gs$gs)
gs$gs
str(gs)
levels(gs$gs)
levels(gs$gs)[5] <- "(0.00895,0.142]"
levels(gs$gs)
levels(gs$SM)
levels(gs$SM)[5] <- "(3.06,11.9]"
levels(gs$gs)
levels(gs$SM)
write.csv(gs, file = "gsCPD.csv")
View(gs)
gsCPDgraph.jpg
plot(dag)
# Load Bayesian network package bnlearn.
library(bnlearn)
# Load network structure learned in clusteredRNApheno3.R.
dag <- model2network("[SM][M10][M6|M10][gs|SM:M6][Photo|gs:M10]
[NSC|Photo][M7|Photo:M6][Starch|NSC][M9|M7:M10]
[fluor|Photo:M9][M2|M7:M9][M3|M6:M9]
[M1|fluor:M2:M10][M5|fluor:M3:M9][M4|M1:M9]
[M8|M1:M6:M10]")
# The network is too small with plot(dag) so the plot will be saved
# as a jpeg and attached.
suppressMessages(library(bnlearn))
?hclust
m6 <- data.frame(bn$M6$prob)
View(m6)
write.csv(m6, file = "m6CPD.csv")
getwd()
write.csv(m6, file = "m6CPD.csv")
bn.fit.barchart(bn$M6)
